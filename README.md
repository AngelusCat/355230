# Комментарии к выбранным решениям

Первым делом, перед написанием кода, была проведена **нормализация** данной в тестовом задании **таблицы** и **вычленение классов**.

**На какие таблицы распалась исходная таблица**:
- events;
- prices;
- tickets;
- orders;
- purchased_tickets;
- users.

**events**:
Содержит информацию о каждом событии (название, описание, начало и конец события).
Почему была создана: наличие атрибутов у события, поле event_date исходной таблицы не зависит от первичного ключа id.

**prices**:
Содержит информацию о ценниках билетов для каждого события (тип билета - цена билета).
Почему была создана: избегание дубликатов; исходная таблица имела поля вроде ticket_adult_price, т.к. таблица содержит все заказы, то там может быть несколько
записей, относящихся к одному событию, а т.к. цена билета зависит от типа и самого события, то эта информация будет дублироваться в исходной таблице.

**tickets**:
На одну запись приходится "реальный" билет на каждое событие.
**Почему была создана**: если обратиться к реальному миру, то каждый билет представляет собой отдельную сущность, а сущность, по DDD, обладает собственным жизненным циклом (билет создается,
переходит из одного состояния в другой).

**orders**:
Содержит информацию обо всех заказах в системе.
Представляет собой преобразованную исходную таблицу.

**purchased_tickets**:
Содержит информацию о деталях покупки билета (barcode, в каком заказе был куплен).
**Почему была создана**: потому что билет имеет два статуса "свободный для продажи" и "куплен", билет со вторым статусом обладает дополнительными атрибутами - barcode и id заказа, т.к.
эти атрибуты характерны только для билетов со статусом "куплен", то эти атрибуты неоптимально хранить там же, где и обычные билеты (присутствие NULL-значений указывает, что
мы имеем дело с разными сущностями).

**users**:
Содержит информацию о пользователях.
**Почему была создана**: потому что исходная таблица содержала user_id.

**На основе этих таблиц были созданы следующие классы**:
- Event;
- Order;
- PurchasedTicket;
- Ticket;
- User;
- Price.

А также: перечисления **TicketStatus** и **TicketType**, чтобы контролировать тип значения.

Помимо этих классов были созданы **ApiSite** (имитирует поведение API), **Barcode** (единое место для генерации barcode для всей системы), **EventMapper** (слой между БД и объектами в 
оперативной памяти).
